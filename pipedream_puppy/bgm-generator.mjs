import { axios } from "@pipedream/platform";

export default defineComponent({
  name: "BGM Generator",
  description: "Generate background music for Shorts using MusicAPI (Sonic/Suno) - Script Generator 연동",

  props: {
    // Script Generator 출력 (통합 입력)
    script_generator_output: {
      type: "string",
      label: "Script Generator Output (JSON)",
      description: "Script Generator의 전체 출력. 사용: {{JSON.stringify(steps.Shorts_Script_Generator.$return_value)}}",
    },

    // API 설정
    musicapi_key: {
      type: "string",
      label: "MusicAPI API Key",
      description: "Get your API key from https://musicapi.ai/dashboard/apikey",
      secret: true,
    },

    // 음악 생성 모드
    generation_mode: {
      type: "string",
      label: "Generation Mode",
      description: "How to generate the music",
      options: [
        { label: "Auto Mode (Script Generator 기반 - 권장)", value: "auto" },
        { label: "Description Mode (직접 설명 입력)", value: "description" },
        { label: "Custom Mode (직접 스타일 지정)", value: "custom" },
      ],
      default: "auto",
    },

    // Description Mode 옵션
    music_description: {
      type: "string",
      label: "Music Description",
      description: "Describe the music you want (for Description Mode). Max 400 chars.",
      optional: true,
    },

    // Custom Mode 옵션
    music_title: {
      type: "string",
      label: "Music Title",
      description: "Title for the music (for Custom Mode). Max 120 chars.",
      optional: true,
    },
    music_style: {
      type: "string",
      label: "Music Style/Tags",
      description: "Style tags like 'upbeat pop, energetic, happy'. Max 200 chars for v4, 1000 for v4.5+",
      optional: true,
    },

    // 공통 옵션
    instrumental: {
      type: "boolean",
      label: "Instrumental Only",
      description: "Generate instrumental music without vocals",
      default: true,
    },
    model_version: {
      type: "string",
      label: "Model Version",
      description: "Sonic model version to use",
      options: [
        { label: "Sonic V5 (Latest)", value: "sonic-v5" },
        { label: "Sonic V4.5 Plus", value: "sonic-v4-5-plus" },
        { label: "Sonic V4.5", value: "sonic-v4-5" },
        { label: "Sonic V4", value: "sonic-v4" },
        { label: "Sonic V3.5", value: "sonic-v3-5" },
      ],
      default: "sonic-v4-5",
    },

    // 폴링 설정
    max_wait_seconds: {
      type: "integer",
      label: "Max Wait Time (seconds)",
      description: "Maximum time to wait for music generation",
      default: 300,
    },
  },

  async run({ steps, $ }) {
    const MUSICAPI_BASE = "https://api.musicapi.ai/api/v1";

    // =====================
    // 0. Script Generator 출력 파싱
    // =====================
    const scriptOutput = typeof this.script_generator_output === 'string'
      ? JSON.parse(this.script_generator_output)
      : this.script_generator_output;

    // BGM 관련 정보 추출 (다양한 경로 지원)
    const bgmConfig = scriptOutput.bgm || scriptOutput.pipeline_data?.bgm || {};
    const topicInfo = scriptOutput.topic_info || {};

    // mood 추출 (우선순위: bgm.mood > topic_info.story_context > 기본값)
    const mood = bgmConfig.mood ||
                topicInfo.story_context?.music_mood ||
                scriptOutput.mood ||
                scriptOutput.input?.target_emotion ||
                "calm";

    // content_style 추출
    const contentStyle = bgmConfig.content_style ||
                        topicInfo.category ||
                        scriptOutput.input?.content_style ||
                        "pet";

    // music_suggestion 추출
    const musicSuggestion = bgmConfig.music_suggestion ||
                           scriptOutput.pipeline_data?.metadata?.music ||
                           topicInfo.story_context?.viral_elements?.join(", ") ||
                           "";

    // ★ 총 영상 길이 (스크립트 길이 기반 동적 duration)
    const targetDuration = scriptOutput.total_duration_seconds ||
                          scriptOutput.pipeline_data?.total_duration_seconds ||
                          scriptOutput.duration_info?.final_duration ||
                          40;

    // ★ 풍자 모드인지 확인 (인터뷰 형식 등)
    const isSatire = topicInfo.is_satire || false;
    const scriptFormat = topicInfo.script_format || "monologue";

    $.export("input_parsed", {
      mood,
      content_style: contentStyle,
      music_suggestion: musicSuggestion?.substring(0, 100),
      target_duration: targetDuration,
      is_satire: isSatire,
      script_format: scriptFormat,
    });

    // =====================
    // 1. Auto Mode: Script Generator 기반 스타일 결정
    // =====================
    let autoGeneratedDescription = null;
    let autoGeneratedTags = null;

    if (this.generation_mode === "auto") {
      $.export("status", "Analyzing script for BGM style...");

      // 무드 → BGM 스타일 매핑
      const moodToBgmStyle = {
        // target_emotion 값들
        touching: "emotional, heartfelt, sentimental, moving, cinematic",
        healing: "peaceful, calming, ambient, relaxing, gentle",
        funny: "playful, quirky, upbeat, fun, lighthearted",
        empathy: "warm, emotional, soft, touching, relatable",
        passion: "energetic, inspiring, powerful, motivational, uplifting",
        calm: "peaceful, serene, gentle, soothing, ambient",
        cute: "playful, sweet, bright, cheerful, adorable",
        warm: "cozy, gentle, heartwarming, soft, comforting",
      };

      // content_style → BGM 스타일 매핑
      const contentStyleToBgm = {
        pet: "cute, heartwarming, playful, gentle, warm",
        motivational: "inspiring, uplifting, powerful, energetic, hopeful",
        healing: "calming, ambient, peaceful, relaxing, soft",
        story: "cinematic, emotional, narrative, dramatic, moving",
        comedy: "funny, quirky, upbeat, playful, bouncy",
        educational: "bright, clear, friendly, informative, engaging",
        asmr: "soft, ambient, whisper, gentle, relaxing",
        daily: "casual, friendly, warm, cozy, natural",
        cute: "adorable, sweet, playful, bright, cheerful",
        satire: "news-like, dramatic, tension, quirky, ironic",  // ★ 풍자용
        interview: "news, professional, light tension, serious yet playful",  // ★ 인터뷰용
      };

      // BGM 스타일 요소 수집
      let bgmElements = [];

      // ★ 풍자/인터뷰 형식이면 해당 스타일 추가
      if (isSatire) {
        bgmElements.push(contentStyleToBgm.satire);
      }
      if (scriptFormat === "interview") {
        bgmElements.push(contentStyleToBgm.interview);
      }

      // mood 기반 스타일 추가
      if (moodToBgmStyle[mood]) {
        bgmElements.push(moodToBgmStyle[mood]);
      }

      // content_style 기반 스타일 추가
      if (contentStyleToBgm[contentStyle]) {
        bgmElements.push(contentStyleToBgm[contentStyle]);
      }

      // music_suggestion에서 키워드 추출 (AI가 제안한 음악 스타일)
      if (musicSuggestion) {
        // 일반적인 음악 관련 키워드 추출
        const musicKeywords = musicSuggestion.toLowerCase()
          .replace(/[^\w\s,]/g, '')
          .split(/[\s,]+/)
          .filter(word => word.length > 3)
          .slice(0, 5);
        if (musicKeywords.length > 0) {
          bgmElements.push(musicKeywords.join(", "));
        }
      }

      // 기본값 (분석 결과가 없을 경우)
      if (bgmElements.length === 0) {
        bgmElements.push("gentle, warm, background music");
      }

      // 최종 태그 생성 (중복 제거)
      const uniqueElements = [...new Set(bgmElements.join(", ").split(", ").map(s => s.trim()).filter(s => s))];
      autoGeneratedTags = uniqueElements.slice(0, 12).join(", ");
      autoGeneratedDescription = `${autoGeneratedTags}, background music for ${targetDuration} second short video`;

      $.export("auto_analysis", {
        mood,
        content_style: contentStyle,
        music_suggestion: musicSuggestion?.substring(0, 100),
        generated_tags: autoGeneratedTags,
        target_duration: targetDuration,
      });
    }

    // =====================
    // 2. 음악 생성 요청
    // =====================
    $.export("status", "Requesting music generation...");

    let requestBody = {
      mv: this.model_version,
      make_instrumental: this.instrumental,
    };

    if (this.generation_mode === "auto") {
      // Auto Mode: Script Generator 기반
      requestBody.custom_mode = true;
      requestBody.title = "Shorts_BGM";
      requestBody.tags = autoGeneratedTags || "gentle, warm, background music";
    } else if (this.generation_mode === "description") {
      // Description Mode: 사용자 설명 입력
      requestBody.custom_mode = false;
      requestBody.gpt_description_prompt = this.music_description || "upbeat background music for short video, energetic and catchy";
    } else {
      // Custom Mode: 직접 스타일 지정
      requestBody.custom_mode = true;
      requestBody.title = this.music_title || "Shorts BGM";
      requestBody.tags = this.music_style || "upbeat, energetic, pop, background music";
    }

    $.export("request_params", {
      mode: this.generation_mode,
      model: this.model_version,
      instrumental: this.instrumental,
      tags: requestBody.tags || requestBody.gpt_description_prompt,
    });

    // 생성 요청
    const createResponse = await axios($, {
      method: "POST",
      url: `${MUSICAPI_BASE}/sonic/create`,
      headers: {
        "Authorization": `Bearer ${this.musicapi_key}`,
        "Content-Type": "application/json",
      },
      data: requestBody,
    });

    if (!createResponse.task_id) {
      throw new Error(`Failed to create music task: ${JSON.stringify(createResponse)}`);
    }

    const taskId = createResponse.task_id;
    $.export("task_id", taskId);

    // =====================
    // 3. 생성 완료 대기 (폴링)
    // =====================
    $.export("status", "Waiting for music generation...");

    let result = null;
    const startTime = Date.now();
    const maxWaitMs = this.max_wait_seconds * 1000;
    const pollInterval = 5000; // 5초마다 확인

    while (Date.now() - startTime < maxWaitMs) {
      await new Promise(resolve => setTimeout(resolve, pollInterval));

      const statusResponse = await axios($, {
        method: "GET",
        url: `${MUSICAPI_BASE}/sonic/task/${taskId}`,
        headers: {
          "Authorization": `Bearer ${this.musicapi_key}`,
        },
      });

      const taskStatus = statusResponse.status || statusResponse.state;
      $.export("poll_status", taskStatus);

      if (taskStatus === "complete" || taskStatus === "completed" || taskStatus === "succeeded") {
        result = statusResponse;
        break;
      } else if (taskStatus === "failed" || taskStatus === "error") {
        throw new Error(`Music generation failed: ${statusResponse.error || "Unknown error"}`);
      }

      // data 배열에서 개별 곡 상태 확인
      const songs = statusResponse.data || statusResponse.clips || [];
      if (Array.isArray(songs) && songs.length > 0) {
        const firstSong = songs[0];
        const songComplete = firstSong.state === "succeeded" ||
                            firstSong.state === "complete" ||
                            (firstSong.duration && firstSong.duration > 0 &&
                             firstSong.audio_url && !firstSong.audio_url.includes('audiopipe'));
        if (songComplete) {
          result = statusResponse;
          break;
        }
      }

      // 진행 상황 업데이트
      if (statusResponse.progress) {
        $.export("progress", `${statusResponse.progress}%`);
      }
    }

    if (!result) {
      throw new Error(`Music generation timed out after ${this.max_wait_seconds} seconds`);
    }

    // =====================
    // 4. 결과 처리
    // =====================
    $.export("status", "Processing generated music...");

    // MusicAPI는 보통 2곡을 생성
    const songs = result.data || result.songs || result.clips || [];

    if (songs.length === 0) {
      throw new Error("No songs were generated");
    }

    const generatedSongs = songs.map((song, index) => ({
      index,
      id: song.id || song.clip_id,
      title: song.title || `BGM_${index + 1}`,
      audio_url: song.audio_url || song.song_url || song.url,
      duration: song.duration,
      style: song.tags || song.style,
    }));

    $.export("songs_generated", generatedSongs.length);

    // =====================
    // 5. 결과 반환
    // =====================
    // 완료된 곡만 필터링 (audiopipe URL 제외)
    const completedSongs = generatedSongs.filter(
      song => song.audio_url && !song.audio_url.includes('audiopipe.suno.ai')
    );

    // 첫 번째 완료된 곡의 URL을 bgm_url로 사용
    const primaryBgm = completedSongs[0] || generatedSongs[0];

    $.export("$summary", `Generated ${completedSongs.length} BGM tracks (target: ${targetDuration}s)`);

    return {
      success: true,
      task_id: taskId,
      model: this.model_version,
      mode: this.generation_mode,
      instrumental: this.instrumental,

      // Script Generator 기반 분석 결과
      auto_analysis: this.generation_mode === "auto" ? {
        mood,
        content_style: contentStyle,
        music_suggestion: musicSuggestion,
        generated_tags: autoGeneratedTags,
      } : null,

      // 타겟 duration (스크립트 길이 기반)
      target_duration_seconds: targetDuration,

      // 생성된 곡들
      songs: generatedSongs,

      // Creatomate 연동용 - Suno CDN URL 직접 사용
      bgm_url: primaryBgm?.audio_url,
      bgm_duration: primaryBgm?.duration,
    };
  },
});
