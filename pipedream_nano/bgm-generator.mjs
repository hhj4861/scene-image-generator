import { axios } from "@pipedream/platform";

export default defineComponent({
  name: "BGM Generator",
  description: "Generate background music for Shorts using MusicAPI (Sonic/Suno)",

  props: {
    // API 설정
    musicapi_key: {
      type: "string",
      label: "MusicAPI API Key",
      description: "Get your API key from https://musicapi.ai/dashboard/apikey",
      secret: true,
    },

    // 음악 생성 모드
    generation_mode: {
      type: "string",
      label: "Generation Mode",
      description: "How to generate the music",
      options: [
        { label: "Auto Mode (Scene 분석 기반)", value: "auto" },
        { label: "Description Mode (직접 설명 입력)", value: "description" },
        { label: "Custom Mode (직접 스타일 지정)", value: "custom" },
      ],
      default: "auto",
    },

    // Auto Mode 옵션 (Scene Image Generator 연동)
    scene_style_guide: {
      type: "string",
      label: "Scene Style Guide (JSON)",
      description: "Style guide from Scene Image Generator (auto-filled from previous step)",
      optional: true,
    },
    script_text: {
      type: "string",
      label: "Script Text",
      description: "Original script text for mood analysis",
      optional: true,
    },

    // Description Mode 옵션
    music_description: {
      type: "string",
      label: "Music Description",
      description: "Describe the music you want (for Description Mode). Max 400 chars.",
      optional: true,
    },

    // Custom Mode 옵션
    music_title: {
      type: "string",
      label: "Music Title",
      description: "Title for the music (for Custom Mode). Max 120 chars.",
      optional: true,
    },
    music_style: {
      type: "string",
      label: "Music Style/Tags",
      description: "Style tags like 'upbeat pop, energetic, happy'. Max 200 chars for v4, 1000 for v4.5+",
      optional: true,
    },
    lyrics: {
      type: "string",
      label: "Lyrics",
      description: "Song lyrics (optional, leave empty for instrumental)",
      optional: true,
    },

    // 공통 옵션
    instrumental: {
      type: "boolean",
      label: "Instrumental Only",
      description: "Generate instrumental music without vocals",
      default: true,
    },
    model_version: {
      type: "string",
      label: "Model Version",
      description: "Sonic model version to use",
      options: [
        { label: "Sonic V5 (Latest)", value: "sonic-v5" },
        { label: "Sonic V4.5 Plus", value: "sonic-v4-5-plus" },
        { label: "Sonic V4.5", value: "sonic-v4-5" },
        { label: "Sonic V4", value: "sonic-v4" },
        { label: "Sonic V3.5", value: "sonic-v3-5" },
      ],
      default: "sonic-v4-5",
    },

    // 폴링 설정
    max_wait_seconds: {
      type: "integer",
      label: "Max Wait Time (seconds)",
      description: "Maximum time to wait for music generation",
      default: 300,
    },
  },

  async run({ steps, $ }) {
    const MUSICAPI_BASE = "https://api.musicapi.ai/api/v1";

    // =====================
    // 1. Auto Mode: Scene 분석 기반 스타일 결정
    // =====================
    let autoGeneratedDescription = null;
    let autoGeneratedTags = null;

    if (this.generation_mode === "auto") {
      $.export("status", "Analyzing scene style for BGM...");

      // Scene Style Guide 파싱
      let styleGuide = null;
      if (this.scene_style_guide) {
        try {
          styleGuide = typeof this.scene_style_guide === "string"
            ? JSON.parse(this.scene_style_guide)
            : this.scene_style_guide;
        } catch (e) {
          console.log("Failed to parse scene_style_guide, using defaults");
        }
      }

      // 무드 키워드 → BGM 스타일 매핑
      const moodToBgmStyle = {
        // 긍정적/활기찬
        happy: "upbeat, cheerful, positive, bright",
        joyful: "happy, celebratory, uplifting, fun",
        energetic: "high energy, driving, powerful, dynamic",
        excited: "exciting, fast-paced, thrilling, intense",
        playful: "fun, quirky, lighthearted, bouncy",

        // 차분한/평화로운
        calm: "peaceful, serene, gentle, soothing",
        peaceful: "tranquil, ambient, relaxing, soft",
        relaxing: "chill, laid-back, mellow, easy-going",
        serene: "peaceful, flowing, ethereal, ambient",

        // 감정적/드라마틱
        dramatic: "cinematic, epic, orchestral, powerful",
        emotional: "heartfelt, touching, sentimental, moving",
        romantic: "lovely, tender, sweet, warm",
        melancholic: "sad, reflective, nostalgic, bittersweet",
        nostalgic: "retro, vintage, warm, reminiscent",

        // 긴장/미스터리
        mysterious: "dark, enigmatic, suspenseful, atmospheric",
        tense: "suspenseful, anxious, building, intense",
        dark: "moody, brooding, ominous, heavy",
        suspenseful: "thriller, tension, dramatic, edge",

        // 영감/동기부여
        inspirational: "uplifting, motivational, hopeful, soaring",
        epic: "grand, orchestral, heroic, powerful",
        triumphant: "victorious, celebratory, majestic, bold",

        // 기타
        futuristic: "electronic, synth, sci-fi, modern",
        vintage: "retro, classic, old-school, warm",
        urban: "hip-hop, trap, street, modern",
        nature: "organic, acoustic, earthy, natural",
      };

      // 아트 스타일 → BGM 스타일 매핑
      const artStyleToBgm = {
        anime: "j-pop inspired, bright, dynamic, youthful",
        photorealistic: "cinematic, film score, atmospheric",
        digital_art: "electronic, modern, synth, creative",
        watercolor: "soft, delicate, acoustic, gentle",
        "3d_render": "modern, electronic, playful, animated",
        oil_painting: "classical, orchestral, rich, dramatic",
        cinematic: "film score, epic, orchestral, dramatic",
      };

      // 스타일 가이드에서 정보 추출
      const moodKeywords = styleGuide?.mood_keywords || [];
      const artStyle = styleGuide?.art_style || "";
      const colorPalette = styleGuide?.color_palette || "";

      // BGM 설명 생성
      let bgmElements = [];

      // 무드 키워드 처리
      for (const mood of moodKeywords) {
        const lowerMood = mood.toLowerCase();
        if (moodToBgmStyle[lowerMood]) {
          bgmElements.push(moodToBgmStyle[lowerMood]);
        } else {
          bgmElements.push(lowerMood);
        }
      }

      // 아트 스타일 처리
      const normalizedArtStyle = artStyle.toLowerCase().replace(/\s+/g, "_");
      if (artStyleToBgm[normalizedArtStyle]) {
        bgmElements.push(artStyleToBgm[normalizedArtStyle]);
      }

      // 색상 팔레트에서 분위기 추출
      if (colorPalette) {
        if (colorPalette.includes("dark") || colorPalette.includes("shadow")) {
          bgmElements.push("moody, atmospheric");
        }
        if (colorPalette.includes("bright") || colorPalette.includes("vibrant")) {
          bgmElements.push("bright, energetic");
        }
        if (colorPalette.includes("warm") || colorPalette.includes("golden")) {
          bgmElements.push("warm, cozy");
        }
        if (colorPalette.includes("cool") || colorPalette.includes("blue")) {
          bgmElements.push("cool, calm");
        }
      }

      // 기본값 (분석 결과가 없을 경우)
      if (bgmElements.length === 0) {
        bgmElements.push("upbeat, modern, background music");
      }

      // 최종 설명 생성
      const uniqueElements = [...new Set(bgmElements.join(", ").split(", "))];
      autoGeneratedDescription = `${uniqueElements.slice(0, 8).join(", ")} background music for short video`;
      autoGeneratedTags = uniqueElements.slice(0, 10).join(", ");

      $.export("auto_analysis", {
        mood_keywords: moodKeywords,
        art_style: artStyle,
        generated_description: autoGeneratedDescription,
        generated_tags: autoGeneratedTags,
      });
    }

    // =====================
    // 2. 음악 생성 요청
    // =====================
    $.export("status", "Requesting music generation...");

    let requestBody = {
      mv: this.model_version,
      make_instrumental: this.instrumental,
    };

    if (this.generation_mode === "auto") {
      // Auto Mode: Scene 분석 기반
      requestBody.custom_mode = true;
      requestBody.title = "Shorts_BGM";
      requestBody.tags = autoGeneratedTags || "upbeat, energetic, background music";
    } else if (this.generation_mode === "description") {
      // Description Mode: 사용자 설명 입력
      requestBody.custom_mode = false;
      requestBody.gpt_description_prompt = this.music_description || "upbeat background music for short video, energetic and catchy";
    } else {
      // Custom Mode: 직접 스타일 지정
      requestBody.custom_mode = true;
      requestBody.title = this.music_title || "Shorts BGM";
      requestBody.tags = this.music_style || "upbeat, energetic, pop, background music";

      if (!this.instrumental && this.lyrics) {
        requestBody.prompt = this.lyrics;
      }
    }

    $.export("request_params", {
      mode: this.generation_mode,
      model: this.model_version,
      instrumental: this.instrumental,
    });

    // 생성 요청
    const createResponse = await axios($, {
      method: "POST",
      url: `${MUSICAPI_BASE}/sonic/create`,
      headers: {
        "Authorization": `Bearer ${this.musicapi_key}`,
        "Content-Type": "application/json",
      },
      data: requestBody,
    });

    if (!createResponse.task_id) {
      throw new Error(`Failed to create music task: ${JSON.stringify(createResponse)}`);
    }

    const taskId = createResponse.task_id;
    $.export("task_id", taskId);

    // =====================
    // 2. 생성 완료 대기 (폴링)
    // =====================
    $.export("status", "Waiting for music generation...");

    let result = null;
    const startTime = Date.now();
    const maxWaitMs = this.max_wait_seconds * 1000;
    const pollInterval = 5000; // 5초마다 확인

    while (Date.now() - startTime < maxWaitMs) {
      await new Promise(resolve => setTimeout(resolve, pollInterval));

      const statusResponse = await axios($, {
        method: "GET",
        url: `${MUSICAPI_BASE}/sonic/task/${taskId}`,
        headers: {
          "Authorization": `Bearer ${this.musicapi_key}`,
        },
      });

      const taskStatus = statusResponse.status || statusResponse.state;
      $.export("poll_status", taskStatus);

      if (taskStatus === "complete" || taskStatus === "completed" || taskStatus === "succeeded") {
        result = statusResponse;
        break;
      } else if (taskStatus === "failed" || taskStatus === "error") {
        throw new Error(`Music generation failed: ${statusResponse.error || "Unknown error"}`);
      }

      // data 배열에서 개별 곡 상태 확인
      const songs = statusResponse.data || statusResponse.clips || [];
      if (Array.isArray(songs) && songs.length > 0) {
        const firstSong = songs[0];
        const songComplete = firstSong.state === "succeeded" ||
                            firstSong.state === "complete" ||
                            (firstSong.duration && firstSong.duration > 0 &&
                             firstSong.audio_url && !firstSong.audio_url.includes('audiopipe'));
        if (songComplete) {
          result = statusResponse;
          break;
        }
      }

      // 진행 상황 업데이트
      if (statusResponse.progress) {
        $.export("progress", `${statusResponse.progress}%`);
      }
    }

    if (!result) {
      throw new Error(`Music generation timed out after ${this.max_wait_seconds} seconds`);
    }

    // =====================
    // 3. 결과 처리
    // =====================
    $.export("status", "Processing generated music...");

    // MusicAPI는 보통 2곡을 생성
    const songs = result.data || result.songs || result.clips || [];

    if (songs.length === 0) {
      throw new Error("No songs were generated");
    }

    const generatedSongs = songs.map((song, index) => ({
      index,
      id: song.id || song.clip_id,
      title: song.title || `BGM_${index + 1}`,
      audio_url: song.audio_url || song.song_url || song.url,
      duration: song.duration,
      style: song.tags || song.style,
    }));

    $.export("songs_generated", generatedSongs.length);

    // =====================
    // 4. 결과 반환
    // =====================
    // 참고: Suno CDN이 Node.js 다운로드 요청을 차단하여 GCS 업로드 불가
    // Creatomate는 서버에서 Suno CDN에 직접 접근 가능하므로 URL 직접 전달

    // 완료된 곡만 필터링 (audiopipe URL 제외)
    const completedSongs = generatedSongs.filter(
      song => song.audio_url && !song.audio_url.includes('audiopipe.suno.ai')
    );

    $.export("$summary", `Generated ${completedSongs.length} BGM tracks`);

    // 첫 번째 완료된 곡의 URL을 bgm_url로 사용
    const primaryBgm = completedSongs[0] || generatedSongs[0];

    return {
      success: true,
      task_id: taskId,
      model: this.model_version,
      mode: this.generation_mode,
      instrumental: this.instrumental,
      auto_analysis: this.generation_mode === "auto" ? {
        generated_tags: autoGeneratedTags,
        generated_description: autoGeneratedDescription,
      } : null,
      songs: generatedSongs,
      // Creatomate 연동용 - Suno CDN URL 직접 사용
      bgm_url: primaryBgm?.audio_url,
      bgm_duration: primaryBgm?.duration,
    };
  },
});
